from django.shortcuts import render, redirect, get_object_or_404
from django.views.generic import CreateView, DetailView, ListView, UpdateView
from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.urls import reverse_lazy
from django.http import JsonResponse
from django.views.decorators.http import require_http_methods
from .models import Booking


class BookingCreateView(LoginRequiredMixin, CreateView):
    """Create a new booking"""
    model = Booking
    template_name = 'bookings/create.html'
    fields = ['check_in_date', 'check_out_date', 'num_guests', 'special_requests']
    
    def form_valid(self, form):
        # Add booking logic here
        messages.success(self.request, 'Booking created successfully!')
        return super().form_valid(form)


class BookingDetailView(LoginRequiredMixin, DetailView):
    """View booking details"""
    model = Booking
    template_name = 'bookings/detail.html'
    context_object_name = 'booking'


class BookingConfirmView(LoginRequiredMixin, UpdateView):
    """Confirm booking"""
    model = Booking
    template_name = 'bookings/confirm.html'
    fields = []


class BookingCancelView(LoginRequiredMixin, UpdateView):
    """Cancel booking"""
    model = Booking
    template_name = 'bookings/cancel.html'
    fields = []


class MyBookingsView(LoginRequiredMixin, ListView):
    """List user's bookings"""
    model = Booking
    template_name = 'bookings/my_bookings.html'
    context_object_name = 'bookings'
    
    def get_queryset(self):
        return Booking.objects.filter(guest=self.request.user).order_by('-created_at')


@login_required
def host_bookings(request):
    """List bookings for host's properties"""
    if request.user.role != 'host':
        messages.error(request, 'Access denied. You must be a host to view this page.')
        return redirect('accounts:profile')
    
    from accommodations.models import Accommodation
    from django.core.paginator import Paginator
    
    bookings = Booking.objects.filter(
        accommodation__host=request.user
    ).select_related(
        'guest', 'accommodation'
    ).order_by('-created_at')
    
    # Filter by status if requested
    status_filter = request.GET.get('status')
    if status_filter and status_filter in ['pending', 'confirmed', 'checked_in', 'completed', 'cancelled']:
        bookings = bookings.filter(status=status_filter)
    
    paginator = Paginator(bookings, 15)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'bookings': page_obj,
        'status_filter': status_filter,
        'status_counts': {
            'all': bookings.count(),
            'pending': bookings.filter(status='pending').count(),
            'confirmed': bookings.filter(status='confirmed').count(),
            'completed': bookings.filter(status='completed').count(),
            'cancelled': bookings.filter(status='cancelled').count(),
        }
    }
    
    return render(request, 'bookings/host_bookings.html', context)


@login_required
@require_http_methods(["POST"])
def check_availability(request):
    """AJAX endpoint to check accommodation availability"""
    from accommodations.models import Accommodation
    from django.utils import timezone
    from datetime import datetime
    from decimal import Decimal
    
    accommodation_id = request.POST.get('accommodation_id')
    check_in = request.POST.get('check_in_date')
    check_out = request.POST.get('check_out_date')
    
    try:
        accommodation = Accommodation.objects.get(
            pk=accommodation_id,
            status='active',
            is_available=True
        )
        
        check_in_date = datetime.strptime(check_in, '%Y-%m-%d').date()
        check_out_date = datetime.strptime(check_out, '%Y-%m-%d').date()
        
        if check_in_date >= check_out_date:
            return JsonResponse({
                'available': False,
                'message': 'Check-out date must be after check-in date'
            })
        
        if check_in_date < timezone.now().date():
            return JsonResponse({
                'available': False,
                'message': 'Check-in date cannot be in the past'
            })
        
        # Check for overlapping bookings
        overlapping_bookings = Booking.objects.filter(
            accommodation=accommodation,
            status__in=['confirmed', 'checked_in'],
            check_in_date__lt=check_out_date,
            check_out_date__gt=check_in_date
        )
        
        if overlapping_bookings.exists():
            return JsonResponse({
                'available': False,
                'message': 'This accommodation is not available for the selected dates'
            })
        
        # Calculate pricing
        nights = (check_out_date - check_in_date).days
        accommodation_cost = nights * accommodation.price_per_night
        cleaning_fee = accommodation.cleaning_fee or 0
        service_fee = accommodation_cost * Decimal('0.10')
        taxes = (accommodation_cost + service_fee) * Decimal('0.08')
        total_cost = accommodation_cost + cleaning_fee + service_fee + taxes
        
        return JsonResponse({
            'available': True,
            'pricing': {
                'nights': nights,
                'accommodation_cost': float(accommodation_cost),
                'cleaning_fee': float(cleaning_fee),
                'service_fee': float(service_fee),
                'taxes': float(taxes),
                'total_cost': float(total_cost),
            }
        })
    
    except (Accommodation.DoesNotExist, ValueError):
        return JsonResponse({
            'available': False,
            'message': 'Invalid accommodation or dates'
        })


@login_required
@require_http_methods(["POST"])
def send_booking_message(request, pk):
    """Send message related to booking"""
    booking = get_object_or_404(Booking, pk=pk)
    
    # Check permissions
    if request.user not in [booking.guest, booking.accommodation.host]:
        return JsonResponse({'success': False, 'message': 'Permission denied'})
    
    message_text = request.POST.get('message', '').strip()
    if not message_text:
        return JsonResponse({'success': False, 'message': 'Message cannot be empty'})
    
    # For now, just return success - implement message model if needed
    return JsonResponse({
        'success': True,
        'message': 'Message sent successfully',
        'message_data': {
            'sender': request.user.get_full_name(),
            'message': message_text,
            'created_at': timezone.now().strftime('%Y-%m-%d %H:%M')
        }
    })
        return Booking.objects.filter(guest=self.request.user).order_by('-created_at')


@login_required
@require_http_methods(["POST"])
def send_booking_message(request, pk):
    """Send message related to booking"""
    from django.http import JsonResponse
    from django.views.decorators.http import require_http_methods
    from .forms import BookingMessageForm
    
    booking = get_object_or_404(
        Booking,
        pk=pk
    )
    
    # Check permissions
    if request.user not in [booking.guest, booking.accommodation.host]:
        return JsonResponse({'success': False, 'message': 'Permission denied'})
    
    form = BookingMessageForm(request.POST)
    if form.is_valid():
        message = form.save(commit=False)
        message.booking = booking
        message.sender = request.user
        message.save()
        
        return JsonResponse({
            'success': True,
            'message': 'Message sent successfully',
            'message_data': {
                'sender': request.user.get_full_name(),
                'message': message.message,
                'created_at': message.created_at.strftime('%Y-%m-%d %H:%M')
            }
        })
    
    return JsonResponse({'success': False, 'message': 'Invalid message'})


@login_required
@require_http_methods(["POST"])
def check_availability(request):
    """AJAX endpoint to check accommodation availability"""
    from django.http import JsonResponse
    from django.utils import timezone
    from decimal import Decimal
    from datetime import datetime
    from accommodations.models import Accommodation
    
    accommodation_id = request.POST.get('accommodation_id')
    check_in = request.POST.get('check_in_date')
    check_out = request.POST.get('check_out_date')
    
    try:
        accommodation = Accommodation.objects.get(
            pk=accommodation_id,
            status='active',
            is_available=True
        )
        
        check_in_date = datetime.strptime(check_in, '%Y-%m-%d').date()
        check_out_date = datetime.strptime(check_out, '%Y-%m-%d').date()
        
        if check_in_date >= check_out_date:
            return JsonResponse({
                'available': False,
                'message': 'Check-out date must be after check-in date'
            })
        
        if check_in_date < timezone.now().date():
            return JsonResponse({
                'available': False,
                'message': 'Check-in date cannot be in the past'
            })
        
        # Basic availability check (would need to implement is_available_for_dates method)
        is_available = True  # Simplified check
        
        if is_available:
            # Calculate pricing
            nights = (check_out_date - check_in_date).days
            accommodation_cost = nights * accommodation.price_per_night
            cleaning_fee = accommodation.cleaning_fee
            service_fee = accommodation_cost * Decimal('0.10')
            taxes = (accommodation_cost + service_fee) * Decimal('0.08')
            total_cost = accommodation_cost + cleaning_fee + service_fee + taxes
            
            return JsonResponse({
                'available': True,
                'pricing': {
                    'nights': nights,
                    'accommodation_cost': float(accommodation_cost),
                    'cleaning_fee': float(cleaning_fee),
                    'service_fee': float(service_fee),
                    'taxes': float(taxes),
                    'total_cost': float(total_cost),
                }
            })
        else:
            return JsonResponse({
                'available': False,
                'message': 'This accommodation is not available for the selected dates'
            })
    
    except (Accommodation.DoesNotExist, ValueError):
        return JsonResponse({
            'available': False,
            'message': 'Invalid accommodation or dates'
        })


@login_required
def host_bookings(request):
    """List bookings for host's properties"""
    from django.core.paginator import Paginator
    
    if request.user.role != 'host':
        messages.error(request, 'Access denied. You must be a host to view this page.')
        return redirect('accounts:profile')
    
    bookings = Booking.objects.filter(
        accommodation__host=request.user
    ).select_related(
        'guest', 'accommodation'
    ).prefetch_related('payments').order_by('-created_at')
    
    # Filter by status if requested
    status_filter = request.GET.get('status')
    if status_filter and status_filter in ['pending', 'confirmed', 'checked_in', 'completed', 'cancelled']:
        bookings = bookings.filter(status=status_filter)
    
    paginator = Paginator(bookings, 15)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'bookings': page_obj,
        'status_filter': status_filter,
        'status_counts': {
            'all': Booking.objects.filter(accommodation__host=request.user).count(),
            'pending': bookings.filter(status='pending').count(),
            'confirmed': bookings.filter(status='confirmed').count(),
            'completed': bookings.filter(status='completed').count(),
            'cancelled': bookings.filter(status='cancelled').count(),
        }
    }
    
    return render(request, 'bookings/host_bookings.html', context)
